#CPU Scheduling
CPU를 보다 잘 사용하기 위해 프로세스를 잘 배정해야 함

## CPU, I/O 버스트 사이클
프로세스 실행은 cpu 실행과 I/O 대기의 사이클로 구성됨 이 두 사이를 교대로 왔다 갔다 한다.<br>
프로세스 실행은 CPU 버스트로 시작된다. 다음에 I/O 버스트가 발생하며 돌아간다.
![img](https://velog.velcdn.com/images%2Fckstn0777%2Fpost%2Fdc614f38-46cb-4e3e-8cd8-baf1cf39d8f8%2Fimage.png)

## CPU 스케줄러
CPU가 유휴 상태가 될 때마다, 운영체제는 **준비 큐**에 있는 프로세스 중에서 하나를 선택해 실행해야 한다.<br>
선택 절차는 **CPU 스케줄러**에 의해 수행된다. <br>
준비 큐에 들어있는 레코드들은 일반적으로 프로세스들의 **프로세스 제어 블록(PCB)** 들이다.

## 선점 및 비선점 스케줄링

### 선점 스케줄링(Preemptive Scheduling)
> 한 프로세스가 CPU를 할당받아 실행하고 있을 때 다른 프로세스가 CPU를 차지한 프로세스를 중지시키고 CPU를 차지할 수 있는 스케줄링 기법
> 
> 우선 순위가 높은 프로세스를 먼저 수행할 때 유리하고 빠른 응답 시간을 요구하는 대화식 시분할 시스템에 유용하다.
> 
> 하지만 많은 오버헤드가 발생한다.
> 
> ex) Round Roibn, SRT, 선점 우선순위

#### Round Robin
> FCFS에 의해 프로세스들이 보내지면 프로세스는 동일한 시간, `Time Quantum or Time Slice`만큼 CPU를 할당받는다.
> 
> 할당 시간이 크면 FCFS와 같게 되고, 작으면 Context Switching이 잦아져 오버헤드가 증가한다.

#### 선점 우선순위 (Priority Scheduling)
> 우선순위를 부여하여 우선순위가 높은 순서대로 처리
> 
> 우선 순위가 낮은 프로세스는 무한정 기다리는 `Starvation(기아)`가 발생할 수 있다.
> 
> `Aging` 방법으로 Starvation 문제를 해결할 수 있다.

#### SRT (Shortest Remaining Time)
> 짧은 시간 순서대로 프로세스를 수행한다, 남은 처리 시간이 더 짧은 프로세스가 Ready 큐에 들어오면 그 프로세스가 바로 선점된다.
> 
> SJF의 선점 스케줄링 버전이라고 볼 수 있다.

#### 다단계 큐 (Multi-level Queue)
> Readey 큐를 여러개 사용하여 각각의 큐는 자신의 스케줄링 알고리즘을 수행하며, 큐와 큐 사이에도 우선순위를 부여한다.
> 
> 각각의 큐는 각기 다른 `Time Quantum`을 갖는다.
> 
> 우선순위가 낮은 프로세스를 실행하지 못하는 것을 방지할 수 있다.
> 
> 우선순위가 높은 큐는 작은 Time Quantum, 낮은 큐는 큰 Time Quantum 할당
<hr/>

### 비선점 스케줄링 (Non-Preemptive Scheduling)
> 이미 사용되는 CPU를 빼앗지 못하고 사용이 끝날 때 까지 기다리는 스케줄링 기법이다.
> 
> 할당 받은 CPU는 작업이 끝날 때 까지 사용한다.
> 
> 응답 시간을 예측할 수 있고 일괄 처리 방식이 적합하다.
> 
> 모든 프로세스의 요구에 대해서 공정하다.
> 
> 모든 프로세스에 대해 공정하므로 중요도가 높은 작업이 뒤로 밀리는 경우가 발생할 수 있다.
> 
> FCFS, SJF(shortest job first), 우선순위, HRN(heighest response next)

#### FCFS (First Come First Served)
> 큐에 도착한 순서대로 CPU를 할당한다.
> 
> 실행 시간이 짧은게 뒤로 가면 평균 대기 시간이 길어진다.

#### SJF (Shortest Job First)
> 큐 안에 있는 프로세스 중 수행시간이 짧은 것을 먼저 수행

#### HRN (Highest Response Ratio Next)
> 긴 작업과 짧은 작업간의 지나친 불평등을 보완한 기법
>
> 수행시간의 길이와 대기 사간을 모두 고려해 우선순위를 정한다.
>
> 우선순위 = (대기시간 + 실행시간) / (실행시간)

#### 우선순위 (Priority)
> 프로세스에게 우선순위를 부여하여 우선순위가 높은 순서대로 처리한다.
> 
> 오버헤드가 많은 단점이 있으나, 시스템의 응답속도를 증가시킨다.